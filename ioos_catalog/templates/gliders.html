{% extends "layout.html" %}

{% block jumbo %}
<div class="row">
  <ul class="nav-header nav navbar-nav">
    <li><a href="{{ url_for('help') }}">Help</a></li>
    <li> <a href="https://github.com/ioos/catalog/wiki/Roadmap">Roadmap</a></li>
    <li> <a href="https://github.com/ioos/catalog/milestones">Milestones</a></li>
    <li> <a href="{{url_for('feedback')}}">Feedback</a></li>
  <ul>
</div>
{% endblock %}

{% block page %}

<script type="text/javascript" src="{{ url_for('.static', filename='js/d3.v3.min.js') }}"></script>

<div id="main-container" class="container">
  <form>
    <label><input type="radio" name="mode" value="grouped"> Grouped</label>
    <label><input type="radio" name="mode" value="stacked" checked> Stacked</label>
  </form>
  <div class="chart">
  </div>

</div>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

$(document).ready(function() {
    var container = $('.chart');
    renderChart(container);
});

var chartContext = {};

function renderChart(container) {

  chartContext.n = 4; // number of layers
  chartContext.m = 58; // number of samples per layer
  chartContext.stack = d3.layout.stack();
  chartContext.layers = chartContext.stack(d3.range(chartContext.n).map(function() { return bumpLayer(chartContext.m, .1); }));
  chartContext.yGroupMax = d3.max(chartContext.layers, function(layer) { return d3.max(layer, function(d) { return d.y; }); });
  chartContext.yStackMax = d3.max(chartContext.layers, function(layer) { return d3.max(layer, function(d) { return d.y0 + d.y; }); });

  chartContext.margin = {top: 40, right: 10, bottom: 20, left: 10};
  chartContext.width = 960 - chartContext.margin.left - chartContext.margin.right;
  chartContext.height = 500 - chartContext.margin.top - chartContext.margin.bottom;

  chartContext.x = d3.scale.ordinal()
      .domain(d3.range(chartContext.m))
      .rangeRoundBands([0, chartContext.width], .08);

  chartContext.y = d3.scale.linear()
      .domain([0, chartContext.yStackMax])
      .range([chartContext.height, 0]);

  chartContext.color = d3.scale.linear()
      .domain([0, chartContext.n - 1])
      .range(["#aad", "#556"]);

  chartContext.xAxis = d3.svg.axis()
      .scale(chartContext.x)
      .tickSize(0)
      .tickPadding(6)
      .orient("bottom");

  chartContext.svg = d3.select(container[0]).append("svg")
      .attr("width", chartContext.width + chartContext.margin.left + chartContext.margin.right)
      .attr("height", chartContext.height + chartContext.margin.top + chartContext.margin.bottom)
    .append("g")
      .attr("transform", "translate(" + chartContext.margin.left + "," + chartContext.margin.top + ")");

  chartContext.layer = chartContext.svg.selectAll(".layer")
      .data(chartContext.layers)
    .enter().append("g")
      .attr("class", "layer")
      .style("fill", function(d, i) { return chartContext.color(i); });

  chartContext.rect = chartContext.layer.selectAll("rect")
      .data(function(d) { return d; })
    .enter().append("rect")
      .attr("x", function(d) { return chartContext.x(d.x); })
      .attr("y", chartContext.height)
      .attr("width", chartContext.x.rangeBand())
      .attr("height", 0);

  chartContext.rect.transition()
      .delay(function(d, i) { return i * 10; })
      .attr("y", function(d) { return chartContext.y(d.y0 + d.y); })
      .attr("height", function(d) { return chartContext.y(d.y0) - chartContext.y(d.y0 + d.y); });

  chartContext.svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + chartContext.height + ")")
      .call(chartContext.xAxis);

  d3.selectAll("input").on("change", change);

  chartContext.timeout = setTimeout(function() {
    d3.select("input[value=\"grouped\"]").property("checked", true).each(change);
  }, 2000);

}

function change() {
  clearTimeout(chartContext.timeout);
  if (this.value === "grouped") transitionGrouped();
  else transitionStacked();
}

function transitionGrouped() {
  chartContext.y.domain([0, chartContext.yGroupMax]);

  chartContext.rect.transition()
      .duration(500)
      .delay(function(d, i) { return i * 10; })
      .attr("x", function(d, i, j) { return chartContext.x(d.x) + chartContext.x.rangeBand() / chartContext.n * j; })
      .attr("width", chartContext.x.rangeBand() / chartContext.n)
    .transition()
      .attr("y", function(d) { return chartContext.y(d.y); })
      .attr("height", function(d) { return chartContext.height - chartContext.y(d.y); });
}

function transitionStacked() {
  chartContext.y.domain([0, chartContext.yStackMax]);

  chartContext.rect.transition()
      .duration(500)
      .delay(function(d, i) { return i * 10; })
      .attr("y", function(d) { return chartContext.y(d.y0 + d.y); })
      .attr("height", function(d) { return chartContext.y(d.y0) - chartContext.y(d.y0 + d.y); })
    .transition()
      .attr("x", function(d) { return chartContext.x(d.x); })
      .attr("width", chartContext.x.rangeBand());
}

// Inspired by Lee Byron's test data generator.
function bumpLayer(n, o) {

  function bump(a) {
    var x = 1 / (.1 + Math.random()),
        y = 2 * Math.random() - .5,
        z = 10 / (.1 + Math.random());
    for (var i = 0; i < n; i++) {
      var w = (i / n - y) * z;
      a[i] += x * Math.exp(-w * w);
    }
  }

  var a = [], i;
  for (i = 0; i < n; ++i) a[i] = o + o * Math.random();
  for (i = 0; i < 5; ++i) bump(a);
  return a.map(function(d, i) { return {x: i, y: Math.max(0, d)}; });
}

</script>
{% endblock %}
